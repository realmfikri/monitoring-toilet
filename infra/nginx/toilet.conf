## Global upstream maps to avoid duplicating listen blocks.
## Adjust the localhost ports if the backing services move.
map $host $api_upstream {
    default 127.0.0.1:3000;                    # Production API (Fastify)
    toilet-api-dev.example.com 127.0.0.1:3300;  # Development API sandbox
}

map $host $app_upstream {
    default 127.0.0.1:4173;                    # Vite preview / production SPA
    toilet-app-dev.example.com 127.0.0.1:5173;  # Live Vite dev server
}

## Cache behaviour expected by Cloudflare: prod SPA assets are cacheable,
## everything else should bypass cache (API + dev SPA).
map $host $app_cache_control {
    default "public, max-age=31536000, immutable";
    toilet-app-dev.example.com "no-store";
}

map $host $app_cache_bypass {
    default 0;
    toilet-app-dev.example.com 1;
}

map $host $app_shell_cache_control {
    default "no-cache";
    toilet-app-dev.example.com "no-store";
}

# Shared TLS configuration snippet. Certificates are renewed by Certbot
# (see infra/nginx/systemd/) and reloaded automatically.
# Cloudflare Authenticated Origin Pulls are enforced via the client cert.
# The Origin Pull CA must be mounted at /etc/nginx/certs/cloudflare-origin-pull-ca.pem
# from the provisioner or secret store.
ssl_session_timeout 1d;
ssl_session_cache shared:SSL:10m;
ssl_protocols TLSv1.2 TLSv1.3;
ssl_prefer_server_ciphers off;

# --- toilet-api.* --------------------------------------------------------
server {
    listen 80;
    listen [::]:80;
    server_name toilet-api.example.com toilet-api-dev.example.com;

    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name toilet-api.example.com toilet-api-dev.example.com;

    ssl_certificate     /etc/letsencrypt/live/toilet-api.example.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/toilet-api.example.com/privkey.pem;
    ssl_client_certificate /etc/nginx/certs/cloudflare-origin-pull-ca.pem;
    ssl_verify_client on;

    include snippets/ssl-params.conf;

    set $api_upstream_url http://$api_upstream;

    location / {
        proxy_pass $api_upstream_url;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header CF-Connecting-IP $http_cf_connecting_ip;
        proxy_set_header CF-IPCountry $http_cf_ipcountry;

        proxy_buffering off;
        proxy_cache_bypass 1;
        proxy_no_cache 1;
        add_header Cache-Control "no-store" always;

        # WAF expectations: API endpoints are considered dynamic and should
        # always bypass cache at both Nginx and Cloudflare layers.
    }
}

# --- toilet-app.* --------------------------------------------------------
server {
    listen 80;
    listen [::]:80;
    server_name toilet-app.example.com toilet-app-dev.example.com;

    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name toilet-app.example.com toilet-app-dev.example.com;

    ssl_certificate     /etc/letsencrypt/live/toilet-app.example.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/toilet-app.example.com/privkey.pem;
    ssl_client_certificate /etc/nginx/certs/cloudflare-origin-pull-ca.pem;
    ssl_verify_client on;

    include snippets/ssl-params.conf;

    set $app_upstream_url http://$app_upstream;

    # Default route proxies the SPA shell. Cloudflare caches only the HTML shell
    # for a very short period to support WAF inspection without serving stale UI.
    location / {
        proxy_pass $app_upstream_url;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header CF-Connecting-IP $http_cf_connecting_ip;

        proxy_cache_bypass $app_cache_bypass;
        proxy_no_cache $app_cache_bypass;
        add_header Cache-Control $app_shell_cache_control always;
    }

    # Static assets are fingerprinted and safe to cache aggressively in prod.
    location ~* \.(?:js|css|png|jpg|jpeg|gif|svg|ico|woff2?)$ {
        proxy_pass $app_upstream_url;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header CF-Connecting-IP $http_cf_connecting_ip;

        proxy_cache_bypass $app_cache_bypass;
        proxy_no_cache $app_cache_bypass;
        add_header Cache-Control $app_cache_control always;
        expires 1y;

        # Align with Cloudflare: static files are cached via immutable fingerprints.
    }
}
